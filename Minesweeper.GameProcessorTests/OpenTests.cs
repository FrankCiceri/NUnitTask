using NUnit.Framework;
using Minesweeper.Core;
using Minesweeper.Core.Enums;

namespace Minesweeper.GameProcessorTests
{
    [TestFixture]
    public class OpenTests
    {
        private GameProcessor gameProcessor;
        [SetUp]
        public void SetUp (){
            bool[,] field = { {true, false,false,false },
                              {false,true, false, false},
                              { true, false,false,false}, };

            gameProcessor = new GameProcessor(field);

        }


        [TestCase(0, 0)]
        //[TestCase(1, 0)]  //this case should give error on test execution since it does not give the expected result, because that position in the array has no mines
        [TestCase(1, 1)]
        public void Open_MinePoints_GameStateLose(int x, int y)      {

           

             var gameState = gameProcessor.Open(x, y);
             var expected = Core.Enums.GameState.Lose;
             Assert.AreEqual(expected, gameState, "The Open() method does not return the GameState.Lose successfully" );               

            
        }




        [Test]
        public void Open_NonMinePoints_GameStateWin()
        {
            gameProcessor.Open(3, 2); //Clearing the field and only leaving the mines
            gameProcessor.Open(1, 0);
            gameProcessor.Open(0, 1);
            //var gameState = gameProcessor.Open(0, 1); //uncomment this line, and comment the one below, it will cause the test to fail since Open() will return GameState.active instead of GameState.Win

            var gameState = gameProcessor.Open(1, 2);

            var expected = Core.Enums.GameState.Win;

            Assert.AreEqual(expected, gameState, "The Open() method does not return the GameState.Win successfully");


        }

        [TestCase(0, 0)] 
        //[TestCase(0, 1)] //this case should give error on test execution since it does not throw the exception, because we did not change the status of the game.
        public void Open_PointWhenGameNotActive_ThrowsException(int x, int y)
        {
            var gameState = gameProcessor.Open(x,y);
            Assert.Throws<InvalidOperationException>(()=> gameProcessor.Open(3, 2),"There should be an exception being thrown out since the GameState changed");   

        }

        public void Open_NonMinePoint_GameStateActive() {


            var gameState = gameProcessor.Open(3, 2);
          
            //var gameState = gameProcessor.Open(0, 0); //uncomment this line will cause the test to fail since Open() will return GameState.Lose instead of GameState.Active
                     

            var expected = Core.Enums.GameState.Active;

            Assert.AreEqual(expected, gameState, "The Open() method does not return the GameState.Active successfully");


        }
        [TestCase(3,2,ExpectedResult = PointState.Neighbors0)]
        [TestCase(0, 1, ExpectedResult = PointState.Neighbors3)]
        //[TestCase(0, 1, ExpectedResult = PointState.Neighbors0)] //on Point 0,1, there should retrieve 3 mines, so if we use PointState.Neighbors0, the test will fail.
        public PointState Open_NonMinePoint_UpdateNeighbors(int x, int y) {

            gameProcessor.Open(x, y);
            return gameProcessor.GetCurrentField()[y, x];

        }



    }
}